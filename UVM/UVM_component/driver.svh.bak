import uvm_pkg::*;
`include "uvm_macros.svh"
`include "systolic_array_if.vh"

class driver extends uvm_driver#(transaction);
  `uvm_component_utils(driver)

  virtual systolic_array_if vif;

  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction: new

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    // get interface
    if(!uvm_config_db#(virtual systolic_array_if)::get(this, "", "systolic_vif", vif)) begin
      `uvm_fatal("Driver", "No virtual interface specified for this test instance");
    end
  endfunction: build_phase

  task run_phase(uvm_phase phase);
    transaction req_item;

    forever begin
      `uvm_info ("Driver", $sformatf ("In Driver"), UVM_NONE)
      seq_item_port.get_next_item(req_item);

      ////input matrix
      `uvm_info ("Driver", $sformatf ("Got item"), UVM_NONE)
      repeat(4)@(posedge vif.clk); // for reset logic

      `uvm_info ("Driver", $sformatf ("Wait for reset over"), UVM_NONE)
      
      vif.weight_en        <= 0;
      vif.input_en         <= 0;
      vif.partial_en       <= 0;
      vif.row_in_en        <= '0;
      vif.row_ps_en        <= '0;
      vif.array_in         <= '0;
      vif.array_in_partials<= '0;

      foreach (req_item.plan[i]) begin
        transaction_elem e = req_item.plan[i];
        repeat (e.pre_idle_cycles) @(posedge vif.clk);
        @(posedge vif.clk);

        case (req_item.phase_kind)
          PH_LOAD_W: begin
            vif.weight_en <= e.en;
            vif.row_in_en <= e.addr;         // 你的 if 里 row_in_en 好像是“行选择”；若是 one-hot/idx，按需修改
            vif.array_in  <= e.data;         // 32bit 数据
            // 其他口关
            vif.input_en  <= 0;
            vif.partial_en<= 0;
          end

          PH_CALC: begin
          // 你原注释“input matrix”在 calc 阶段送？如果你把“输入矩阵阶段”叫 PH_CALC，就在这里打 input 通道
          vif.input_en  <= e.en;
          vif.row_in_en <= e.addr;
          vif.array_in  <= e.data;
          vif.weight_en <= 0;
          vif.partial_en<= 0;
        end

          PH_WAIT: begin
            // 等待阶段：全部关（或只保持 out_en 监视）
            vif.weight_en <= 0;
            vif.input_en  <= 0;
            vif.partial_en<= 0;
          end

          PH_OUTPUT: begin
          // 如果 OUTPUT 阶段需要给 partial 通道预装数据（看你协议），这里示例 partial
          vif.partial_en        <= e.en;
          vif.row_ps_en         <= e.addr;
          vif.array_in_partials <= e.data;
          vif.weight_en         <= 0;
          vif.input_en          <= 0;
          end

          default: begin // PH_IDLE
          vif.weight_en <= 0;
          vif.input_en  <= 0;
          vif.partial_en<= 0;
        end
      endcase

      @(posedge vif.clk);
      vif.weight_en        <= 0;
      vif.input_en         <= 0;
      vif.partial_en       <= 0;

      //repeat(4) @(negedge vif.out_en);
      seq_item_port.item_done();
      end
end
  endtask: run_phase

endclass: driver
 